<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Simulating the Skeleton of a Processor Core | Designing a RISC-V Processor Core</title>
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="Simulating the Skeleton of a Processor Core" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Simulating the Skeleton of a Processor Core This is the first post in our multi series blog describing the process of designing a RISC-V processor core using a hardware definition language, namely SystemVerilog. In this post we are not going to go much into the process of designing the processor core itself. Rather, this post will focus on the getting started part, which we need to accomplish before implement the actual processor design." />
<meta property="og:description" content="Simulating the Skeleton of a Processor Core This is the first post in our multi series blog describing the process of designing a RISC-V processor core using a hardware definition language, namely SystemVerilog. In this post we are not going to go much into the process of designing the processor core itself. Rather, this post will focus on the getting started part, which we need to accomplish before implement the actual processor design." />
<link rel="canonical" href="https://tonmoy18.github.io/riscv-cpu-blog/2020/02/01/getting-started.html" />
<meta property="og:url" content="https://tonmoy18.github.io/riscv-cpu-blog/2020/02/01/getting-started.html" />
<meta property="og:site_name" content="Designing a RISC-V Processor Core" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-02-01T19:36:25-06:00" />
<script type="application/ld+json">
{"headline":"Simulating the Skeleton of a Processor Core","dateModified":"2020-02-01T19:36:25-06:00","datePublished":"2020-02-01T19:36:25-06:00","description":"Simulating the Skeleton of a Processor Core This is the first post in our multi series blog describing the process of designing a RISC-V processor core using a hardware definition language, namely SystemVerilog. In this post we are not going to go much into the process of designing the processor core itself. Rather, this post will focus on the getting started part, which we need to accomplish before implement the actual processor design.","mainEntityOfPage":{"@type":"WebPage","@id":"https://tonmoy18.github.io/riscv-cpu-blog/2020/02/01/getting-started.html"},"@type":"BlogPosting","url":"https://tonmoy18.github.io/riscv-cpu-blog/2020/02/01/getting-started.html","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/riscv-cpu-blog/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://tonmoy18.github.io/riscv-cpu-blog/feed.xml" title="Designing a RISC-V Processor Core" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/riscv-cpu-blog/">Designing a RISC-V Processor Core</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/riscv-cpu-blog/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Simulating the Skeleton of a Processor Core</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2020-02-01T19:36:25-06:00" itemprop="datePublished">Feb 1, 2020
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h1 id="simulating-the-skeleton-of-a-processor-core">Simulating the Skeleton of a Processor Core</h1>
<p>This is the first post in our <a href="/riscv-cpu-blog/">multi series blog</a> describing the process of designing a RISC-V processor core using a hardware definition language, namely SystemVerilog. In this post we are not going to go much into the process of designing the processor core itself. Rather, this post will focus on the getting started part, which we need to accomplish before implement the actual processor design.</p>

<p>The first step in creating our own processor core is to create the testbench, the models and to set up the simulation environment. To simulate our processor core, we need to instantiate it at a top level from where we can apply different stimulus (or inputs) to the core and monitor the outputs to verify the correctness of our design.</p>

<p>Moreover, we do not need to “design” the the memory our processor core is going to be using. The actual memory in real life would probably be a separate chip, a different IP on the same chip or SoC, or maybe even an embedded block if using an FPGA. It would however, not be practical to design an actual memory using a hardware definition language like SystemVerilog. Nevertheless, to simulate our processor core, we would need to have something to use as a memory block. For the purposes of this tutorial, we are going to write some very basic memory models and then we will use that model to verify the correctness of our processor core.</p>

<h2 id="creating-the-memory-model">Creating the Memory Model</h2>

<p>For the memory, we are going to create a model with dual read/write ports. These two ports will be able to read from or write to the same memory space simultaneously. One of these would be used as the instruction memory and the other one would be for data memory. We can save the memory model in vsim/models/dual_port_memory.sv file. This model is going to have enable, write enable, data in and address as inputs for each of the two memory ports. The outputs would be busy signal and the data out bus for each of the two ports. The model needs to have an address space declared as an array. The input output ports we are going to be using as as follows:</p>

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>rst_n_i</td>
      <td>I</td>
      <td>Asynchronous active low reset</td>
    </tr>
    <tr>
      <td>clk_i</td>
      <td>I</td>
      <td>Clock</td>
    </tr>
    <tr>
      <td>en[1|2]_i</td>
      <td>I</td>
      <td>Enable signal for memory port [1|2]</td>
    </tr>
    <tr>
      <td>wen[1|2]_i</td>
      <td>I</td>
      <td>Write enable signal for memory port [1|2]</td>
    </tr>
    <tr>
      <td>addr[1|2]_i</td>
      <td>I</td>
      <td>Address bus for memory port [1|2]</td>
    </tr>
    <tr>
      <td>data[1|2]_in_i</td>
      <td>I</td>
      <td>Data in bus for memory port [1|2]</td>
    </tr>
    <tr>
      <td>data[1|2]_busy_o</td>
      <td>O</td>
      <td>Memory port [1|2] busy indicator</td>
    </tr>
    <tr>
      <td>data[1|2]_out_o</td>
      <td>O</td>
      <td>Data out bus for memory port [1|2]</td>
    </tr>
  </tbody>
</table>

<p>We will use a parameter <code class="highlighter-rouge">MEMSIZE</code> to identify the size of the memory in bytes. We will make the default value of this parameter <code class="highlighter-rouge">'h10000</code> which is 64kB of memory. Our memory model is going to be very simple and will be able to read/write 4 bytes at a time and only accept 4byte aligned memory addresses. To easily support this, we can just divide the memory size in bytes by 4 and use that number as the size of the memory space array where each element will be a 32 bit logic element. We will name this array <code class="highlighter-rouge">data</code> and declare it the following way.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">  <span class="k">parameter</span> <span class="kt">int</span> <span class="n">MEMSIZE</span> <span class="o">=</span> <span class="mh">'h10000</span><span class="p">;</span>  <span class="c1">// Has to be multiple of 4</span>
  <span class="k">localparam</span> <span class="kt">int</span> <span class="n">MEMSIZE_BY_4</span> <span class="o">=</span> <span class="n">MEMSIZE</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>

  <span class="kt">logic</span> <span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">data</span><span class="p">[</span><span class="n">MEMSIZE_BY_4</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">];</span>  <span class="c1">// MEMSIZE bytes</span></code></pre></figure>

<p>We need to know the address space offset where the generated machine code is going to reside. The programs we will generate will have the text section starting at a non zero address. And to make the simulation use less memory, we are only going to model the address starting form this address + 64kB. We will keep the text section offset into a parameter called <code class="highlighter-rouge">TEXT_OFFSET</code> and the offset for the data section into <code class="highlighter-rouge">DATA_OFFSET</code>. For now we can keep whatever default values in them and later when instantiating the memory model we can give the proper parameter values.</p>

<p>Outputting the data out will happen only when the enable signal is hi and the write signal is lo. In this simple model we are going to output the data instantly instead of waiting for the next clock cycle. However, we will use the internal busy signal to mask the data out. Later we will be able to use random or fixed pattern of the busy signal to verify that our processor core is able to stall properly when the memory is busy. The actual data out code would be very simple combinational logic and would look like this:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">  <span class="k">always_comb</span> <span class="k">begin</span>
    <span class="n">data1_out_o</span> <span class="o">=</span> <span class="mb">'0</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">wen1_i</span> <span class="o">==</span> <span class="mb">1'b0</span> <span class="o">&amp;&amp;</span>
        <span class="n">en1_i</span> <span class="o">==</span> <span class="mb">1'b1</span> <span class="o">&amp;&amp;</span>
        <span class="n">data1_busy_o</span> <span class="o">==</span> <span class="mb">1'b0</span><span class="p">)</span> <span class="k">begin</span>

      <span class="n">data1_out_o</span> <span class="o">=</span> <span class="n">data</span><span class="p">[(</span><span class="n">addr1_i</span> <span class="o">-</span> <span class="n">TEXT_OFFSET</span><span class="p">)</span><span class="o">/</span><span class="mi">4</span><span class="p">];</span>
    <span class="k">end</span>
  <span class="k">end</span></code></pre></figure>

<p>Note that we would need something similar for the other memory port as well.</p>

<p>To implement the memory write logic into out model we are going to need to use the clock. The writing will happen only on the positive edge of the input clock and when both the applicable enable and write enable signals are hi. It could look something like this:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">  <span class="k">always_ff</span> <span class="o">@</span> <span class="p">(</span><span class="kt">posedge</span> <span class="n">clk_i</span><span class="p">)</span> <span class="k">begin</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">wen1_i</span> <span class="o">==</span> <span class="mb">1'b1</span><span class="p">)</span> <span class="k">begin</span>
      <span class="n">data</span><span class="p">[(</span><span class="n">addr1_i</span> <span class="o">-</span> <span class="n">TEXT_OFFSET</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">data1_in_i</span><span class="p">;</span>
    <span class="k">end</span>
  <span class="k">end</span></code></pre></figure>

<p>Again, we would need to implement something similar for the other memory port as well.</p>

<p>Finally, we need a way to load the memory content from input hex file at the beginning of simulation. For this we can make use of the Verilog <code class="highlighter-rouge">$readmemh</code> command. This takes the hex file name as the first argument and the memory array as the second argument. Note, that this hex file is not the intel hex file. This file is a just ascii hex values. Moreover, we want a way to provide the name of the hexfile as argument when running the simulator. This way we would not have ot re-compile the verilated C++ code for running different hexfiles and we can do quick regression of all of our assembled code quickly. For this we can use the Verilog command <code class="highlighter-rouge">$value$plusargs</code>, which takes a pattern as the first argument and the string variable to store the result into as the second argument (I personally don’t like passing argument as reference and then modifying them, but we are stuck with Verilog…). Our initial block inside the dual_port_mem module would look like this:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">  <span class="k">initial</span> <span class="k">begin</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">HEXFILE_FROM_ARG</span><span class="p">)</span> <span class="k">begin</span> 
      <span class="k">if</span> <span class="p">($</span><span class="n">value</span><span class="p">$</span><span class="n">plusargs</span><span class="p">(</span><span class="s">"text_hexfile=%s"</span><span class="p">,</span> <span class="n">memfile</span><span class="p">))</span> <span class="k">begin</span>
        <span class="p">$</span><span class="nb">display</span><span class="p">(</span><span class="s">"INFO: loading %s"</span><span class="p">,</span> <span class="n">memfile</span><span class="p">);</span>
        <span class="p">$</span><span class="nb">readmemh</span><span class="p">(</span><span class="n">memfile</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
      <span class="k">end</span> <span class="k">else</span>
        <span class="p">$</span><span class="nb">display</span><span class="p">(</span><span class="s">"ERROR opening hexfile"</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">($</span><span class="n">value</span><span class="p">$</span><span class="n">plusargs</span><span class="p">(</span><span class="s">"data_hexfile=%s"</span><span class="p">,</span> <span class="n">memfile</span><span class="p">))</span> <span class="k">begin</span>
        <span class="p">$</span><span class="nb">display</span><span class="p">(</span><span class="s">"INFO: loading %s"</span><span class="p">,</span> <span class="n">memfile</span><span class="p">);</span>
        <span class="p">$</span><span class="nb">readmemh</span><span class="p">(</span><span class="n">memfile</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">DATA_OFFSET</span> <span class="o">-</span> <span class="n">TEXT_OFFSET</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span><span class="p">);</span>
      <span class="k">end</span> <span class="k">else</span>
        <span class="p">$</span><span class="nb">display</span><span class="p">(</span><span class="s">"ERROR opening hexfile"</span><span class="p">);</span>
    <span class="k">end</span> <span class="k">else</span> <span class="k">begin</span>
      <span class="p">$</span><span class="nb">readmemh</span><span class="p">(</span><span class="n">MEMFILE</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
    <span class="k">end</span>
  <span class="k">end</span></code></pre></figure>

<p>Here <code class="highlighter-rouge">memfile</code> is a string and <code class="highlighter-rouge">MEMFILE</code> is a string parameter that is set to a hexfile with all zeros as default. <code class="highlighter-rouge">HEXFILE_FROM_ARG</code> is an int parameter that defaults to 0, but can be set as 1 from the instantiating module. This way from the top level we can provide either an explicit memory file or set <code class="highlighter-rouge">HEXFIRL_FROM_ARG</code> to 1 to make the module load the memory file based on the simulator argument. The final memory model we are going to be using can be found <a href="https://github.com/tonmoy18/riscv-cpu-blog/blob/post-01/vsim/models/dual_port_mem.sv">here</a>.</p>

<h2 id="creating-the-testbench-top-and-the-processor-core-skeleton">Creating the Testbench Top and the Processor Core Skeleton</h2>
<p>Next we are going to create the basic module file for our processor core. We will keep this file in src/core.sv. For now this is going to be just an empty shell with the inputs and outputs defined. It is going to look like this:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">module</span> <span class="n">core</span><span class="p">(</span>
  <span class="n">rst_n_i</span><span class="p">,</span>
  <span class="n">clk_i</span><span class="p">,</span>
  
  <span class="n">dm_dout_i</span><span class="p">,</span>
  <span class="n">dm_wen_o</span><span class="p">,</span>
  <span class="n">dm_en_o</span><span class="p">,</span>
  <span class="n">dm_din_o</span><span class="p">,</span>
  <span class="n">dm_addr_o</span><span class="p">,</span>
  <span class="n">dm_busy_i</span><span class="p">,</span>
  
  <span class="n">im_dout_i</span><span class="p">,</span>
  <span class="n">im_addr_o</span><span class="p">,</span>
  <span class="n">im_busy_i</span>
<span class="p">);</span>

  <span class="kt">input</span> <span class="kt">logic</span> <span class="n">rst_n_i</span><span class="p">;</span>
  <span class="kt">input</span> <span class="kt">logic</span> <span class="n">clk_i</span><span class="p">;</span>

  <span class="kt">input</span> <span class="kt">logic</span> <span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">dm_dout_i</span><span class="p">;</span>
  <span class="kt">output</span> <span class="kt">logic</span> <span class="n">dm_wen_o</span><span class="p">;</span>
  <span class="kt">output</span> <span class="kt">logic</span> <span class="n">dm_en_o</span><span class="p">;</span>
  <span class="kt">output</span> <span class="kt">logic</span> <span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">dm_din_o</span><span class="p">;</span>
  <span class="kt">output</span> <span class="kt">logic</span> <span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">dm_addr_o</span><span class="p">;</span>
  <span class="kt">input</span> <span class="kt">logic</span> <span class="n">dm_busy_i</span><span class="p">;</span>

  <span class="kt">input</span> <span class="kt">logic</span> <span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">im_dout_i</span><span class="p">;</span>
  <span class="kt">output</span> <span class="kt">logic</span> <span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">im_addr_o</span><span class="p">;</span>
  <span class="kt">input</span> <span class="kt">logic</span> <span class="n">im_busy_i</span><span class="p">;</span>

<span class="k">endmodule</span></code></pre></figure>

<p>Our simulation top module is going to be very simple as well. We are going to give this module a creative name, “top”. This module will just instantiate the dual_port_mem and the core modules. We are going to declare some local signals and use them to connect the core and the dual port memory with proper corresponding signals. We are going to use the memory port 1 as the interface used by data memory and the memory port 2 as the instruction memory. Hence these signals are connected in this way in top.sv. Notice that we need to provide the values for the parameters <code class="highlighter-rouge">HEXFILE_FROM_ARG</code>, <code class="highlighter-rouge">TEXT_OFFSET</code>, and <code class="highlighter-rouge">DATA_OFFSET</code>. We want the memory model to use the simulator argument to load the initial memory values from. Furthermore, we want the text offset to be 32’h80000000, and the data offset to be 32’h80002000. These values are used by the rocket chip and would be easier to compile code using rocket chip’s link.ld. There is no reason these offset values can’t be something different. This module is going to have the reset and the clock signals as input, which will be driven from the verilator program. For communication with the outside world, we are going to create a very basic model of this functionality. Out “tohost” address is going to be 32’h80001000. To model data being sent to the host using a top level port, we are going to have the output signals tohost_int_o, and tohost_data_o. The idea being, whenever there is data on this port for the host, the int signal is going to be raised and the host needs to read it instantly. This simple logic can be modeled using these two lines of combinational code:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">  <span class="k">assign</span> <span class="n">tohost_int_o</span> <span class="o">=</span> <span class="p">(</span><span class="n">dm_wen</span> <span class="o">&amp;&amp;</span> <span class="n">dm_addr</span> <span class="o">==</span> <span class="mh">32'h80001000</span><span class="p">);</span>
  <span class="k">assign</span> <span class="n">tohost_data_o</span> <span class="o">=</span> <span class="n">tohost_int_o</span> <span class="o">==</span> <span class="mb">1'b1</span> <span class="o">?</span> <span class="n">dm_din</span> <span class="o">:</span> <span class="mb">'0</span><span class="p">;</span></code></pre></figure>

<p>We are going to keep this file in <code class="highlighter-rouge">vsim/tb/top.sv</code> location. And the entire file should look like this:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">module</span> <span class="n">top</span><span class="p">(</span>
  <span class="n">rst_n</span><span class="p">,</span>
  <span class="n">clk</span><span class="p">,</span>
  <span class="n">tohost_int_o</span><span class="p">,</span>
  <span class="n">tohost_data_o</span>
<span class="p">);</span>

  <span class="kt">input</span> <span class="kt">logic</span> <span class="n">rst_n</span><span class="p">,</span> <span class="n">clk</span><span class="p">;</span>

  <span class="kt">output</span> <span class="kt">logic</span> <span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">tohost_data_o</span><span class="p">;</span>
  <span class="kt">output</span> <span class="kt">logic</span> <span class="n">tohost_int_o</span><span class="p">;</span>

  <span class="kt">logic</span> <span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">dm_dout</span><span class="p">;</span>
  <span class="kt">logic</span> <span class="n">dm_wen</span><span class="p">;</span>
  <span class="kt">logic</span> <span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">dm_din</span><span class="p">;</span>
  <span class="kt">logic</span> <span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">dm_addr</span><span class="p">;</span>
  <span class="kt">logic</span> <span class="n">dm_busy</span><span class="p">;</span>

  <span class="kt">logic</span> <span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">im_dout</span><span class="p">;</span>
  <span class="kt">logic</span> <span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">im_addr</span><span class="p">;</span>
  <span class="kt">logic</span> <span class="n">im_busy</span><span class="p">;</span>

  <span class="n">core</span> <span class="n">u_core</span><span class="p">(</span>
    <span class="p">.</span><span class="n">clk_i</span>          <span class="p">(</span><span class="n">clk</span><span class="p">),</span>
    <span class="p">.</span><span class="n">rst_n_i</span>        <span class="p">(</span><span class="n">rst_n</span><span class="p">),</span>
    
    <span class="p">.</span><span class="n">dm_dout_i</span>      <span class="p">(</span><span class="n">dm_dout</span><span class="p">),</span>
    <span class="p">.</span><span class="n">dm_en_o</span>        <span class="p">(</span><span class="n">dm_en</span><span class="p">),</span>
    <span class="p">.</span><span class="n">dm_wen_o</span>       <span class="p">(</span><span class="n">dm_wen</span><span class="p">),</span>
    <span class="p">.</span><span class="n">dm_din_o</span>       <span class="p">(</span><span class="n">dm_din</span><span class="p">),</span>
    <span class="p">.</span><span class="n">dm_addr_o</span>      <span class="p">(</span><span class="n">dm_addr</span><span class="p">),</span>
    <span class="p">.</span><span class="n">dm_busy_i</span>      <span class="p">(</span><span class="n">dm_busy</span><span class="p">),</span>

    <span class="p">.</span><span class="n">im_dout_i</span>      <span class="p">(</span><span class="n">im_dout</span><span class="p">),</span>
    <span class="p">.</span><span class="n">im_addr_o</span>      <span class="p">(</span><span class="n">im_addr</span><span class="p">),</span>
    <span class="p">.</span><span class="n">im_busy_i</span>      <span class="p">(</span><span class="n">im_busy</span><span class="p">)</span>
  <span class="p">);</span>

  <span class="n">dual_port_mem</span> <span class="p">#(</span>
    <span class="p">.</span><span class="n">HEXFILE_FROM_ARG</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
    <span class="p">.</span><span class="n">TEXT_OFFSET</span><span class="p">(</span><span class="mh">32'h80000000</span><span class="p">),</span>
    <span class="p">.</span><span class="n">DATA_OFFSET</span><span class="p">(</span><span class="mh">32'h80002000</span><span class="p">)</span>
  <span class="p">)</span> <span class="n">u_mem</span> <span class="p">(</span>
    <span class="p">.</span><span class="n">rst_n_i</span>        <span class="p">(</span><span class="n">rst_n</span><span class="p">),</span>
    <span class="p">.</span><span class="n">clk_i</span>          <span class="p">(</span><span class="n">clk</span><span class="p">),</span>
    <span class="p">.</span><span class="n">en1_i</span>          <span class="p">(</span><span class="n">dm_en</span><span class="p">),</span>
    <span class="p">.</span><span class="n">wen1_i</span>         <span class="p">(</span><span class="n">dm_wen</span><span class="p">),</span>
    <span class="p">.</span><span class="n">addr1_i</span>        <span class="p">(</span><span class="n">dm_addr</span><span class="p">),</span>
    <span class="p">.</span><span class="n">data1_in_i</span>     <span class="p">(</span><span class="n">dm_din</span><span class="p">),</span>
    <span class="p">.</span><span class="n">data1_out_o</span>    <span class="p">(</span><span class="n">dm_dout</span><span class="p">),</span>
    <span class="p">.</span><span class="n">data1_busy_o</span>   <span class="p">(</span><span class="n">dm_busy</span><span class="p">),</span>
    <span class="p">.</span><span class="n">en2_i</span>          <span class="p">(</span><span class="mb">1'b1</span><span class="p">),</span>
    <span class="p">.</span><span class="n">wen2_i</span>         <span class="p">(</span><span class="mb">1'b0</span><span class="p">),</span>
    <span class="p">.</span><span class="n">addr2_i</span>        <span class="p">(</span><span class="n">im_addr</span><span class="p">),</span>
    <span class="p">.</span><span class="n">data2_in_i</span>     <span class="p">(</span><span class="mh">32'h0000</span><span class="p">),</span>
    <span class="p">.</span><span class="n">data2_out_o</span>    <span class="p">(</span><span class="n">im_dout</span><span class="p">),</span>
    <span class="p">.</span><span class="n">data2_busy_o</span>   <span class="p">(</span><span class="n">im_busy</span><span class="p">)</span>
  <span class="p">);</span>

  <span class="k">assign</span> <span class="n">tohost_int_o</span> <span class="o">=</span> <span class="p">(</span><span class="n">dm_wen</span> <span class="o">&amp;&amp;</span> <span class="n">dm_addr</span> <span class="o">==</span> <span class="mh">32'h80001000</span><span class="p">);</span>
  <span class="k">assign</span> <span class="n">tohost_data_o</span> <span class="o">=</span> <span class="n">tohost_int_o</span> <span class="o">==</span> <span class="mb">1'b1</span> <span class="o">?</span> <span class="n">dm_din</span> <span class="o">:</span> <span class="mb">'0</span><span class="p">;</span>

<span class="k">endmodule</span></code></pre></figure>

<h2 id="running-the-simulation-and-viewing-signals">Running the Simulation and Viewing Signals</h2>
<p>To run the simulation, we will need a top level c++ program that instantiates the top level SystemVerilog module and provides proper inputs and checks the expected outputs. We could have skipped a step and just instantiated the memory and the core in this program. But this way we get to keep the <code class="highlighter-rouge">top.sv</code> unchanged and use it as the top level for any other non-verilator simulator what we may use later. I have created a cpp file by making slight modification to the sim_main.cpp file given as an example. We will save the modified cpp file in <code class="highlighter-rouge">vsim/sim_main.cpp</code>. There is a lot going on in this file. The changes that we are going to make in this file includes adding the ability to run the program with an extra argument to set the logfile name. This will help us run multiple RISCV programs as regression tests. The other major change is inside the main function itself:</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp">    <span class="c1">// Set some inputs</span>
    <span class="n">top</span><span class="o">-&gt;</span><span class="n">rst_n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">top</span><span class="o">-&gt;</span><span class="n">eval</span><span class="p">();</span>
    <span class="n">top</span><span class="o">-&gt;</span><span class="n">clk</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">top</span><span class="o">-&gt;</span><span class="n">eval</span><span class="p">();</span>
    <span class="n">top</span><span class="o">-&gt;</span><span class="n">clk</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">top</span><span class="o">-&gt;</span><span class="n">eval</span><span class="p">();</span>
    <span class="n">top</span><span class="o">-&gt;</span><span class="n">rst_n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">top</span><span class="o">-&gt;</span><span class="n">eval</span><span class="p">();</span>

    <span class="kt">int</span> <span class="n">test_done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    
    <span class="c1">// Simulate until $finish</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">Verilated</span><span class="o">::</span><span class="n">gotFinish</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">main_time</span> <span class="o">&lt;</span> <span class="mi">6000</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">main_time</span><span class="o">++</span><span class="p">;</span>
        <span class="n">top</span><span class="o">-&gt;</span><span class="n">clk</span> <span class="o">^=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">main_time</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">top</span><span class="o">-&gt;</span><span class="n">tohost_int_o</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">test_status</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">top</span><span class="o">-&gt;</span><span class="n">tohost_data_o</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">test_status</span> <span class="o">=</span> <span class="s">"PASS"</span><span class="p">;</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="n">test_status</span> <span class="o">=</span> <span class="s">"FAIL"</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"TEST %sED</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">test_status</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>
                <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span> <span class="n">f</span><span class="p">;</span>
                <span class="n">f</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="n">logout</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">ios</span><span class="o">::</span><span class="n">out</span><span class="p">);</span>
                <span class="n">f</span> <span class="o">&lt;&lt;</span> <span class="n">test_status</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
                <span class="n">f</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
                <span class="n">test_done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        
        <span class="n">top</span><span class="o">-&gt;</span><span class="n">eval</span><span class="p">();</span>
<span class="cp">#if VM_TRACE        
</span>        <span class="n">tfp</span><span class="o">-&gt;</span><span class="n">dump</span><span class="p">(</span><span class="n">main_time</span><span class="p">);</span>
<span class="cp">#endif
</span>    <span class="p">}</span>

    <span class="c1">// Do a couple of clock cycles for easier waveform debugging</span>
    <span class="n">main_time</span><span class="o">++</span><span class="p">;</span>
    <span class="n">top</span><span class="o">-&gt;</span><span class="n">clk</span> <span class="o">^=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">top</span><span class="o">-&gt;</span><span class="n">eval</span><span class="p">();</span>
<span class="cp">#if VM_TRACE        
</span>        <span class="n">tfp</span><span class="o">-&gt;</span><span class="n">dump</span><span class="p">(</span><span class="n">main_time</span><span class="p">);</span>
<span class="cp">#endif
</span>    <span class="n">main_time</span><span class="o">++</span><span class="p">;</span>
    <span class="n">top</span><span class="o">-&gt;</span><span class="n">clk</span> <span class="o">^=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">top</span><span class="o">-&gt;</span><span class="n">eval</span><span class="p">();</span>
<span class="cp">#if VM_TRACE        
</span>        <span class="n">tfp</span><span class="o">-&gt;</span><span class="n">dump</span><span class="p">(</span><span class="n">main_time</span><span class="p">);</span>
<span class="cp">#endif
</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">test_done</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"TEST TIMEOUT"</span><span class="p">);</span>
    <span class="p">}</span></code></pre></figure>

<p>Here we first apply the reset (active lo, rst_n_i = 0 means the parts are in reset), apply a few clock cycles and call the verilator eval function a few times in between. Without calling the eval function, verilator does not apply the inputs to the design. and needs to be called every time an input is changed. In our case we will change the inputs, change the clock and then call the eval function for every clock cycle after reset.</p>

<p>In the while block, we loop until either the $finish function is called from somewhere in Verilog or the main time counter variable has reached a timeout value (6000 in this case). We invert the clock input of top on every iteration of the while loop. We also check whether any data is sent from the processor by polling the the tohost_int signal. We will later use programs that will return 1 in case the test has passed, and hence this kind of check will become very useful. Finally after the loop we apply the clock one ore time to make sure we have some extra data after the test finish condition is over. This ensures that we have enough data after the test finish condition for easier debugging. The final sim_main.cpp file can be found <a href="https://github.com/tonmoy18/riscv-cpu-blog/blob/post-01/vsim/sim_main.cpp">here</a>.</p>

<p>Next step before running the simulation is to create a Makefile for the make tool that we will be using. We will keep this Makefile in the vsim/ directory as well. Similar to the cpp file, we are going to use the verilator example Makefile as a starting point as well. The changes we will make to the Makefile includes adding the <code class="highlighter-rouge">-Wno-fatal</code> flag, adding our src directory as include. Since we are keeping the models and the tb directory within the vsim directory, there is no need to explicitly add these to the input. Finally we will copy the Makefile_obj and the <code class="highlighter-rouge">input.vc</code> files from the Verilator example directory. We have added a couple of variables, namely <code class="highlighter-rouge">HEX</code> and <code class="highlighter-rouge">HEX2</code> to the Makefile. These both point to <code class="highlighter-rouge">hex/zeros.hex</code> where the <code class="highlighter-rouge">zeros.hex</code> is a all zero hexfile. When we run make, we can explicitly set these hexfiles to something else, otherwise the all zeros file will be used by default.</p>

<p><img src="/riscv-cpu-blog/assets/img/post01-getting-started-01.PNG" alt="Viewing signals" class="img-responsive" /></p>

<p>To run the simulation then we need to run <code class="highlighter-rouge">make</code> from the vsim directory. This should create a obj_dir directory with various cpp files in them. Next it will compile these cpp files and use the compiled code to run the simulation. This step should also create a vcd file in the logs directory in the process. To open the vcd file we will need to use a vcd file view. One of the most popular open source vcd file viewer is gtkwave. You can use gtkwave to open the vcd file and look at the signal. Right now our processor core is not going to do anything. All we will be able to see is the reset changing from zero to 1 and the clock signal toggling. We can also plot the instruction memory out and data memory out signals. We expect these values to be zero as well since the memory is loaded from zeros.hex. However, if these are not zero, don’t worry about it. As long as the reset and clock signals behave as expected, it should be ok to go forward with the next steps. In the next blog post we are going to actually start designing the core and we will see more signals toggling.</p>

<p>You can find all the steps described in this post <a href="https://github.com/tonmoy18/riscv-cpu-blog/tree/post-01">here</a></p>

  </div><a class="u-url" href="/riscv-cpu-blog/2020/02/01/getting-started.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/riscv-cpu-blog/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Designing a RISC-V Processor Core</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Designing a RISC-V Processor Core</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/tonmoy18"><svg class="svg-icon"><use xlink:href="/riscv-cpu-blog/assets/minima-social-icons.svg#github"></use></svg> <span class="username">tonmoy18</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Personal site of Tonmoy Roy. The goal of this site is to teach and learn the steps for designing a RISC-V processor core using SysteVerilog</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
